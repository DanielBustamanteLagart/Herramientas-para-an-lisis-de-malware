from flask import Flask, render_template, request
import pefile
import pickle
import os

app = Flask(__name__)

# Cargar el modelo de IA al inicio de la aplicaci칩n
with open('IA/modelo_IA.pkl', 'rb') as model_file:
    clf = pickle.load(model_file)

app.config['STATIC_FOLDER'] = 'static'

def extract_pe_features(file_path):
    pe=pefile.PE(file_path)
    features = [
        int(pe.DOS_HEADER.e_magic),
        int(pe.DOS_HEADER.e_cblp),
        int(pe.DOS_HEADER.e_cp),
        int(pe.DOS_HEADER.e_crlc),
        int(pe.DOS_HEADER.e_cparhdr),
        int(pe.DOS_HEADER.e_minalloc),
        int(pe.DOS_HEADER.e_maxalloc),
        int(pe.DOS_HEADER.e_ss),
        int(pe.DOS_HEADER.e_sp),
        int(pe.DOS_HEADER.e_csum),
        int(pe.DOS_HEADER.e_ip),
        int(pe.DOS_HEADER.e_cs),
        int(pe.DOS_HEADER.e_lfarlc),
        int(pe.DOS_HEADER.e_ovno),
        int(pe.DOS_HEADER.e_oemid),
        int(pe.DOS_HEADER.e_oeminfo),
        int(pe.DOS_HEADER.e_lfanew),
        #int(pe.FILE_HEADER.Machine),
        int(pe.FILE_HEADER.NumberOfSections),
        #int(pe.FILE_HEADER.TimeDateStamp),
        int(pe.FILE_HEADER.PointerToSymbolTable),
        int(pe.FILE_HEADER.NumberOfSymbols),
        int(pe.FILE_HEADER.SizeOfOptionalHeader),
        int(pe.FILE_HEADER.Characteristics),
        int(pe.OPTIONAL_HEADER.Magic),
        int(pe.OPTIONAL_HEADER.MajorLinkerVersion),
        int(pe.OPTIONAL_HEADER.MinorLinkerVersion),
        int(pe.OPTIONAL_HEADER.SizeOfCode),
        int(pe.OPTIONAL_HEADER.SizeOfInitializedData),
        int(pe.OPTIONAL_HEADER.SizeOfUninitializedData),
        int(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
        int(pe.OPTIONAL_HEADER.BaseOfCode),
        int(pe.OPTIONAL_HEADER.ImageBase),
        int(pe.OPTIONAL_HEADER.SectionAlignment),
        int(pe.OPTIONAL_HEADER.FileAlignment),
        int(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion),
        int(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion),
        int(pe.OPTIONAL_HEADER.MajorImageVersion),
        int(pe.OPTIONAL_HEADER.MinorImageVersion),
        int(pe.OPTIONAL_HEADER.MajorSubsystemVersion),
        int(pe.OPTIONAL_HEADER.MinorSubsystemVersion),
        int(pe.OPTIONAL_HEADER.SizeOfHeaders),
        int(pe.OPTIONAL_HEADER.CheckSum),
        int(pe.OPTIONAL_HEADER.SizeOfImage),
        int(pe.OPTIONAL_HEADER.Subsystem),
        int(pe.OPTIONAL_HEADER.DllCharacteristics),
        int(pe.OPTIONAL_HEADER.SizeOfStackReserve),
        int(pe.OPTIONAL_HEADER.SizeOfStackCommit),
        int(pe.OPTIONAL_HEADER.SizeOfHeapReserve),
        int(pe.OPTIONAL_HEADER.SizeOfHeapCommit),
        int(pe.OPTIONAL_HEADER.LoaderFlags),
        int(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes),
        getattr(pe, 'SuspiciousImportFunctions', 0),
        getattr(pe, 'SuspiciousNameSection', 0),
        getattr(pe, 'SectionsLength', 0),
        getattr(pe, 'SectionMinEntropy', 0),		
        int(pe.sections[0].get_entropy()),
        getattr(pe, 'SectionMinRawsize', 0),	
        int(pe.sections[0].SizeOfRawData),
        getattr(pe, 'SectionMinVirtualsize', 0),	
        int(pe.sections[0].Misc_VirtualSize),
        getattr(pe, 'SectionMaxPhysical', 0),
        getattr(pe, 'SectionMinPhysical', 0),			
        int(pe.sections[0].VirtualAddress),
        getattr(pe, 'SectionMinVirtual', 0),	
        int(pe.sections[0].PointerToRawData),
        getattr(pe, 'SectionMinPointerData', 0),
        getattr(pe, 'SectionMaxChar', 0),
        getattr(pe, 'SectionMainChar', 0),	
        int(pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']].VirtualAddress),
        int(pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']].Size),
        int(pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT']].VirtualAddress),
        getattr(pe, 'ImageDirectoryEntryExport', 0),
        getattr(pe, 'ImageDirectoryEntryImport', 0),
        getattr(pe, 'ImageDirectoryEntryResource', 0),
        getattr(pe, 'ImageDirectoryEntryException', 0),
        getattr(pe, 'ImageDirectoryEntrySecurity', 0)
    ]
    return features

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analizar', methods=['POST'])
def analizar():
    # Obtener el archivo del formulario
    archivo = request.files['archivo']

    # Guardar el archivo en el servidor (puedes personalizar la ruta)
    ruta_archivo = 'archivos_subidos/' + archivo.filename
    archivo.save(ruta_archivo)

    # Realizar el an치lisis con el modelo de IA
    caracteristicas_exe = extract_pe_features(ruta_archivo)
    prediccion = clf.predict([caracteristicas_exe])

    # Determinar el resultado del an치lisis
    resultado = "El archivo es clasificado como malware." if prediccion[0] == 1 else "El archivo no es clasificado como malware."

    # Devolver el resultado a la p치gina
    return render_template('index.html', resultado=resultado)


if __name__ == '__main__':
    app.run(debug=True)
